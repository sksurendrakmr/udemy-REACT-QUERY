# React Query in Larger App

- Centralizing fetching indicator / error handling
- refetching data
- integrating auth
- dependent queries
- testing

# Custom Hooks

- In larger app, make custom hook for each type of data
  --> can access from multiple components
  --> no risk of mixing up keys
  --> query function encapsulated in custom hook
  --> abstracts implementation from display layer
  ==> update hook if you change implementation
  ==> no need to update components

We will going to update our app to use a centralized loading indicator instead
of having an individual loading indicator for each component.

For this, we will use a react query hook called useIsFetching.

In smaller apps

- used isFetching from useQuery return object
- Remainder: isLoading is isFetching plus no cached data.

In larger app

- Loading spinner whenever any query isFetching
- We are going to have a centralised loading spinner that's just
  going to be a part of our app component and will turn it on if
  any query is fetching and will turn it off if there aren't any queries.

- useIsFetching will tells us whether there are any queries that are currently
  fetching.

- Thus, no need for isFetching on every custom hook / useQuery call.

===============
passing useQuery errors to Chakra UI "toast" component.

- onError callback to useQuery
- Instead of destructuring isError, error from useQuery return

- onError callback runs if query function throws an error and react query
  passes error parameter to callback.

- will use toast.

======
No useError analogy for useIsFetching

- need more than integer; unclear how to implement

Instead, set default onError handler for queryClient

By default, queryClient takes default either queries or mutations.

{
queries : {useQuery options},
mutations: {useMutation options}
}

Alternative to onError: Error Boundary in react.
To handle react query errors with ErrorBoundary, we can use useErrorBoundary for useQuery

we can either add it in optionto useQuery/ useMutation
or in defaultOptions when creating QueryClient.

If set to true than it propagate errors to the nearest error boundary

https://react-query.tanstack.com/reference/useQuery

===================

# Options for pre-populating data

We want to pre-populate the data if we know what data user needs to see
if there's no data yet in the cache.

==============

# Filtering with the select option

===========

Scenario here : Allow user to filter out any appointments that aren't available.

Why is the select option the best way to do this??

- React Query memo-izes to reduce unnecessary computation.

Under the hood, react query do

- triple equals comparison of select function
- only runs if data changes and the function (select fn) has changed

need a stable function (useCallback for anonymous function)

=========================

setQueryData --> setting data in the cache directly
removeQueries --> removing queries from the cache.
